<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulasi Lensa Cembung & Cekung — Perbaikan</title>
  <meta name="description" content="Simulasi lensa cembung & cekung. Perbaikan: kaca cekung berubah & UI tanpa emoji." />
  <style>
    :root{
      --bg:#0d0d1a;
      --panel:#131323cc;
      --accent1:#a855f7;
      --accent2:#ec4899;
      --muted:#9aa0c7;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family: "Segoe UI", Tahoma, Arial, sans-serif;
      background:var(--bg);
      color:#eef2ff;
      overflow:hidden;
    }

    #root{display:flex;height:100vh;width:100vw}
    .canvas-section{flex:1;position:relative;border-left:1px solid rgba(255,255,255,0.03);background:radial-gradient(circle at top, rgba(255,255,255,0.04), transparent 55%);min-width:260px;display:flex;align-items:stretch;justify-content:stretch;overflow:hidden}
    .canvas-section:first-child{border-left:none}
    canvas{display:block;width:100%;height:100%}
    .section-label{position:absolute;left:18px;top:14px;z-index:20;background:rgba(0,0,0,0.55);padding:6px 12px;border-radius:999px;font-size:13px;color:#f3f6ff;letter-spacing:0.4px}

    /* controls */
    #controls{position:fixed;left:20px;top:20px;width:320px;padding:18px;border-radius:14px;background:var(--panel);box-shadow:0 18px 50px rgba(0,0,0,0.5);z-index:120;backdrop-filter:blur(10px)}
    #controls.hidden{transform:translateX(-360px);opacity:0;pointer-events:none}
    #controls h1{font-size:18px;margin-bottom:10px;text-align:center}
    .control-group{margin-bottom:12px}
    label{display:flex;justify-content:space-between;font-size:13px;color:var(--muted);margin-bottom:6px;font-weight:600}
    .value-display{color:#ffd54f;font-weight:700}
    input[type="range"]{width:100%;height:6px;border-radius:999px;background:rgba(255,255,255,0.08);outline:none}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent1);border:2px solid #fff}
    .button-group{display:flex;gap:8px}
    .button-group button{flex:1;padding:10px 8px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:#fff;cursor:pointer;font-weight:700}
    .button-group button.active{background:linear-gradient(135deg,var(--accent1),var(--accent2));box-shadow:0 8px 24px rgba(168,85,247,0.18);border-color:transparent}
    .small{font-size:12px;color:var(--muted)}

    /* toggles */
    .round-btn{position:fixed;width:46px;height:46px;border-radius:50%;display:grid;place-items:center;background:rgba(118,75,162,0.85);border:none;color:#fff;cursor:pointer;z-index:130;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
    #toggleControls{left:20px;top:20px}
    #toggleInfo{right:20px;top:20px;background:rgba(50,50,60,0.85)}

    /* info panel */
    #info{position:fixed;right:20px;top:20px;width:300px;padding:18px;border-radius:12px;background:rgba(0,0,0,0.6);z-index:120;backdrop-filter:blur(10px)}
    #info.hidden{transform:translateX(360px);opacity:0;pointer-events:none}
    #info h3{color:#ffd700;margin-bottom:6px}
    .info-item{font-size:13px;margin:6px 0;color:#dbe6ff}
    .info-item strong{color:#7cc0ff}

    #footerHints{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;color:#bfc8ff;font-size:13px;z-index:120}
    @media (max-width:900px){#controls{width:260px;left:12px;top:72px}#info{width:220px;right:12px;top:72px}#toggleControls{left:12px}#toggleInfo{right:12px}}
  </style>
</head>
<body>
  <button id="toggleControls" class="round-btn" aria-expanded="true" title="Toggle Controls">Menu</button>
  <button id="toggleInfo" class="round-btn" aria-expanded="true" title="Toggle Info">Info</button>

  <div id="root">
    <div class="canvas-section" aria-label="Diagram optik">
      <div class="section-label">Diagram Optik</div>
      <canvas id="diagramCanvas" role="img" aria-label="3D diagram lensa"></canvas>
    </div>

    <div class="canvas-section" aria-label="Pandangan melalui lensa">
      <div class="section-label">Pandangan Melalui Lensa</div>
      <canvas id="viewCanvas" role="img" aria-label="Pandangan melalui lensa 2D"></canvas>
    </div>
  </div>

  <div id="controls" role="region" aria-label="Kontrol simulasi">
    <h1>Simulasi Lensa — Perbaikan</h1>

    <div class="control-group">
      <label>Tipe Lensa</label>
      <div class="button-group" role="tablist" aria-label="Tipe lensa">
        <button id="btnConvex" class="active" role="tab" aria-selected="true">Cembung</button>
        <button id="btnConcave" role="tab" aria-selected="false">Cekung</button>
      </div>
    </div>

    <div class="control-group">
      <label for="curvature">Kelengkungan Lensa <span id="curvatureValue" class="value-display">1.5</span></label>
      <input id="curvature" type="range" min="0.5" max="3.0" step="0.1" value="1.5" />
      <div class="small">1 = rendah, 3 = sangat melengkung</div>
    </div>

    <div class="control-group">
      <label for="refractive">Indeks Refraksi (n) <span id="refractiveValue" class="value-display">1.50</span></label>
      <input id="refractive" type="range" min="1.30" max="2.00" step="0.01" value="1.50" />
      <div class="small">Bahan lensa (kaca/plastik)</div>
    </div>

    <div class="control-group">
      <label for="objectDist">Jarak Objek (u) <span id="objectDistValue" class="value-display">5.0</span></label>
      <input id="objectDist" type="range" min="1.5" max="12.0" step="0.1" value="5.0" />
      <div class="small">Satuan relatif (sesuai skala visual)</div>
    </div>

    <div class="control-group">
      <label for="thickness">Ketebalan Lensa (d) <span id="thicknessValue" class="value-display">0.30</span></label>
      <input id="thickness" type="range" min="0.05" max="1.00" step="0.01" value="0.30" />
    </div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="btnPreset1" title="Preset: Objek jauh">Preset: Jauh</button>
      <button id="btnPreset2" title="Preset: Dekat">Preset: Dekat</button>
      <button id="btnReset" style="flex:1;background:rgba(255,255,255,0.06)">Reset</button>
    </div>
  </div>

  <div id="info" role="region" aria-label="Informasi lensa">
    <h3>Informasi Lensa</h3>
    <div class="info-item"><strong>Tipe:</strong> <span id="infoType">Cembung</span></div>
    <div class="info-item"><strong>Fokus (f):</strong> <span id="infoFocus">0.00</span> unit</div>
    <div class="info-item"><strong>Jarak Bayangan (v):</strong> <span id="infoImageDist">0.00</span> unit</div>
    <div class="info-item"><strong>Perbesaran (M):</strong> <span id="infoMag">0.00</span>x</div>
    <div class="info-item"><strong>Sifat Bayangan:</strong> <span id="infoNature">-</span></div>
  </div>

  <div id="footerHints">Keyboard: C = cembung • V = cekung • R = reset</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // state
    let lensType = 'convex';
    let curvature = 1.5;
    let refractiveIndex = 1.5;
    let objectDistance = 5.0;
    let thickness = 0.3;

    // DOM
    const diagCanvas = document.getElementById('diagramCanvas');
    const viewCanvas = document.getElementById('viewCanvas');
    const viewCtx = viewCanvas.getContext('2d');

    const btnConvex = document.getElementById('btnConvex');
    const btnConcave = document.getElementById('btnConcave');
    const curvatureIn = document.getElementById('curvature');
    const refractiveIn = document.getElementById('refractive');
    const objectDistIn = document.getElementById('objectDist');
    const thicknessIn = document.getElementById('thickness');

    const curvatureValue = document.getElementById('curvatureValue');
    const refractiveValue = document.getElementById('refractiveValue');
    const objectDistValue = document.getElementById('objectDistValue');
    const thicknessValue = document.getElementById('thicknessValue');

    const infoType = document.getElementById('infoType');
    const infoFocus = document.getElementById('infoFocus');
    const infoImageDist = document.getElementById('infoImageDist');
    const infoMag = document.getElementById('infoMag');
    const infoNature = document.getElementById('infoNature');

    const toggleControlsBtn = document.getElementById('toggleControls');
    const toggleInfoBtn = document.getElementById('toggleInfo');
    const controlsPanel = document.getElementById('controls');
    const infoPanel = document.getElementById('info');

    const btnPreset1 = document.getElementById('btnPreset1');
    const btnPreset2 = document.getElementById('btnPreset2');
    const btnReset = document.getElementById('btnReset');

    // three renderer + scene
    const diagramRenderer = new THREE.WebGLRenderer({ canvas: diagCanvas, antialias: true, alpha: true });
    diagramRenderer.setClearColor('#0a0a15', 1);
    const diagramScene = new THREE.Scene();
    const diagramCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 3000);
    diagramCamera.position.set(0, 0, 450);

    const controls = new OrbitControls(diagramCamera, diagCanvas);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 100;
    controls.maxDistance = 1200;

    const ambient = new THREE.AmbientLight(0xffffff, 0.6); diagramScene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(120,160,200); diagramScene.add(dir);

    const axisGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-700,0,0), new THREE.Vector3(700,0,0)]);
    const axisMat = new THREE.LineDashedMaterial({ color:0xffaa00, dashSize:20, gapSize:12 });
    const principalAxis = new THREE.Line(axisGeom, axisMat); principalAxis.computeLineDistances(); diagramScene.add(principalAxis);

    const grid = new THREE.GridHelper(900, 16, 0x222244, 0x111122); grid.rotation.x = Math.PI/2; grid.position.z = -40; diagramScene.add(grid);

    // lens material
    const lensMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x88ccff,
      metalness: 0.05,
      roughness: 0.2,
      transparent: true,
      opacity: 0.45,
      transmission: 0.9,
      clearcoat: 0.15
    });
    let lensMesh = new THREE.Mesh(new THREE.BoxGeometry(10,10,2), lensMaterial);
    diagramScene.add(lensMesh);

    const objectArrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 80, 0xff4444);
    diagramScene.add(objectArrow);
    const imageArrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 80, 0x44ff44);
    imageArrow.visible = false; diagramScene.add(imageArrow);

    const raysGroup = new THREE.Group(); diagramScene.add(raysGroup);

    const focalHelpers = [
      new THREE.Mesh(new THREE.SphereGeometry(4,12,12), new THREE.MeshBasicMaterial({ color:0xffd700 })),
      new THREE.Mesh(new THREE.SphereGeometry(4,12,12), new THREE.MeshBasicMaterial({ color:0xffd700 }))
    ];
    focalHelpers.forEach(h=>diagramScene.add(h));

    // animate
    function animateDiagram(){ controls.update(); diagramRenderer.render(diagramScene, diagramCamera); requestAnimationFrame(animateDiagram); }
    animateDiagram();

    // focal length (thick lens approximation)
    function calculateFocalLength(){
      const n = refractiveIndex;
      const d = thickness;
      const baseRadius = 4 / Math.max(0.0001, curvature);

      let R1, R2;
      if (lensType === 'convex'){ R1 = baseRadius; R2 = -baseRadius; }
      else { R1 = -baseRadius; R2 = baseRadius; }

      if (Math.abs(R1) < 1e-6 || Math.abs(R2) < 1e-6) return Infinity;
      const term = (1/R1) - (1/R2);
      const extra = ((n-1)*d) / (n * R1 * R2);
      const invf = (n-1) * (term + extra);
      if (Math.abs(invf) < 1e-9) return Infinity;
      return 1 / invf;
    }

    // image calculation (sign conv: object at +left, f positive for converging)
    function calculateImage(){
      const f = calculateFocalLength();
      const u = objectDistance;
      if (!isFinite(f)) return { f, v: Infinity, m: Infinity };
      if (Math.abs(u - f) < 1e-9) return { f, v: Infinity, m: Infinity };
      const invv = (1/f) - (1/u);
      if (Math.abs(invv) < 1e-9) return { f, v: Infinity, m: Infinity };
      const v = 1/invv;
      const m = -v / u;
      return { f, v, m };
    }

    // improved lens geometry: stronger indent for concave so change is obvious
    function createLensGeometry(type, curvatureValue, thicknessValue){
      const lensHeight = 160;
      const halfH = lensHeight / 2;
      const segments = 80;
      const pts = [];
      for (let i = 0; i <= segments; i++){
        const y = -halfH + (i/segments) * lensHeight;
        const norm = Math.abs(y) / halfH;
        const bulgeBase = 18 + thicknessValue * 40;
        const bulge = (1 / Math.max(0.01, curvatureValue)) * 36 * (1 - Math.pow(norm, 1.6));
        // make concave indent more pronounced: multiply factor
        let radius;
        if (type === 'convex') radius = bulgeBase + bulge;
        else radius = Math.max(6, bulgeBase - bulge * 1.6); // stronger indent
        pts.push(new THREE.Vector2(-radius, y));
      }
      for (let i = segments; i >= 0; i--){
        const y = -halfH + (i/segments) * lensHeight;
        const norm = Math.abs(y) / halfH;
        const bulgeBase = 18 + thicknessValue * 40;
        const bulge = (1 / Math.max(0.01, curvatureValue)) * 36 * (1 - Math.pow(norm, 1.6));
        let radius;
        if (type === 'convex') radius = bulgeBase + bulge;
        else radius = Math.max(6, bulgeBase - bulge * 1.6);
        pts.push(new THREE.Vector2(radius, y));
      }

      const shape = new THREE.Shape();
      shape.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) shape.lineTo(pts[i].x, pts[i].y);
      shape.closePath();

      const depth = 6 + thicknessValue * 110;
      const geom = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false, steps:1 });
      geom.center();
      geom.computeVertexNormals();
      return geom;
    }

    function buildLine3(points, color=0xffffff, dashed=false){
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      let material;
      if (dashed){
        material = new THREE.LineDashedMaterial({ color, dashSize:6, gapSize:4, transparent:true, opacity:0.85 });
        geometry.computeLineDistances();
      } else {
        material = new THREE.LineBasicMaterial({ color, linewidth:2 });
      }
      return new THREE.Line(geometry, material);
    }

    function updateRayGroup(group, data){
      while(group.children.length){
        const c = group.children.pop();
        if (c.geometry) c.geometry.dispose();
        if (c.material && c.material.dispose) c.material.dispose();
      }
      if (!data.hasImage) return;

      const lensX = 0;
      const objectTop = new THREE.Vector3(data.objX, data.objHeight, 0);
      const atLens = new THREE.Vector3(lensX, data.objHeight, 0);
      const imagePoint = new THREE.Vector3(data.imgX, data.imgY, 0);
      const isVirtual = !data.realImage;

      if (!isVirtual){
        group.add(buildLine3([objectTop, atLens, imagePoint], 0xff3366));
      } else {
        const projectedDir = atLens.clone().sub(imagePoint).normalize();
        const forwardEnd = atLens.clone().add(projectedDir.multiplyScalar(380));
        group.add(buildLine3([objectTop, atLens, forwardEnd], 0xff3366));
        group.add(buildLine3([atLens, imagePoint], 0xff3366, true));
      }

      const center = new THREE.Vector3(0,0,0);
      const throughCenterEnd = isVirtual ? atLens.clone().add(new THREE.Vector3(260, (data.imgY - data.objHeight)*-0.8,0)) : imagePoint.clone();
      group.add(buildLine3([objectTop, center, throughCenterEnd], 0x33ff66));
    }

    // 2D view drawing with DPR support
    function clear2DForDPR(canvas, ctx){
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || canvas.width;
      const cssH = canvas.clientHeight || canvas.height;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function drawView(){
      clear2DForDPR(viewCanvas, viewCtx);
      const w = viewCanvas.width / (window.devicePixelRatio || 1);
      const h = viewCanvas.height / (window.devicePixelRatio || 1);
      const ctx = viewCtx;
      ctx.fillStyle = '#070713'; ctx.fillRect(0,0,w,h);

      const { f, v, m } = calculateImage();
      const gradient = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.8);
      gradient.addColorStop(0,'rgba(10,10,21,0)'); gradient.addColorStop(0.7,'rgba(10,10,21,0.2)'); gradient.addColorStop(1,'rgba(10,10,21,0.85)');
      ctx.fillStyle = gradient; ctx.fillRect(0,0,w,h);

      if (!isFinite(v) || !isFinite(m)){
        ctx.fillStyle='#7a86ff'; ctx.font='bold 22px system-ui'; ctx.textAlign='center';
        ctx.fillText('Bayangan tidak terbentuk', w/2, h/2-8);
        ctx.font='13px system-ui'; ctx.fillStyle='#9aa3c9';
        ctx.fillText('(Objek berada di titik fokus atau f tak terhingga)', w/2, h/2+20);
        return;
      }

      const centerX = w/2; const centerY = h/2;
      const baseSize = 220; const imgSize = Math.max(12, Math.abs(m)*baseSize);

      ctx.save(); ctx.translate(centerX, centerY);
      if (m < 0) ctx.scale(1, -1);
      const arrowColor = v < 0 ? '#44ff44' : (m < 0 ? '#ffaa44' : '#44ff44');
      ctx.lineWidth = 6; ctx.strokeStyle = arrowColor; ctx.fillStyle = arrowColor;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-imgSize); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-imgSize); ctx.lineTo(-30,-imgSize+40); ctx.lineTo(30,-imgSize+40); ctx.closePath(); ctx.fill();
      ctx.restore();

      ctx.fillStyle='#ffffff'; ctx.font='bold 16px system-ui'; ctx.textAlign='center';
      const sizeText = Math.abs(m) > 1 ? 'DIPERBESAR' : Math.abs(m) < 1 ? 'DIPERKECIL' : 'SAMA BESAR';
      const orientText = m < 0 ? 'TERBALIK' : 'TEGAK';
      const natureText = v > 0 ? 'NYATA' : 'MAYA';
      ctx.fillText(`${natureText} • ${orientText} • ${sizeText}`, centerX, 64);
      ctx.font='13px system-ui'; ctx.fillStyle='#bfc9ff';
      ctx.fillText(`Perbesaran: ${m.toFixed(2)}x`, centerX, h-68);
      ctx.fillText(`Jarak bayangan: ${v.toFixed(2)} unit`, centerX, h-46);
      ctx.fillText(`Fokus: ${f === Infinity || !isFinite(f) ? '∞' : f.toFixed(2)} unit`, centerX, h-24);
    }

    // update 3D diagram scene
    function updateDiagramScene(){
      const { f, v, m } = calculateImage();
      const scale3D = 40;
      const objHeight = 80;
      const objX = -objectDistance * scale3D;
      const imgX = isFinite(v) ? v * scale3D : (v > 0 ? 2000 : -2000);
      const imgY = m < 0 ? -Math.abs(m) * objHeight : Math.abs(m) * objHeight;
      const imgHeight = Math.abs(m) * objHeight;
      const hasImage = isFinite(v) && isFinite(m) && Math.abs(m) < 1e9;

      // recreate lens geometry and force material update
      if (lensMesh.geometry) lensMesh.geometry.dispose();
      const newGeom = createLensGeometry(lensType, curvature, thickness);
      lensMesh.geometry = newGeom;
      lensMesh.geometry.computeBoundingBox && lensMesh.geometry.computeBoundingBox();
      lensMesh.material.color.set(lensType === 'convex' ? 0x88ccff : 0xffbb88);
      lensMesh.material.needsUpdate = true;

      objectArrow.position.set(objX, 0, 0); objectArrow.setDirection(new THREE.Vector3(0,1,0)); objectArrow.setLength(objHeight, 14, 8);

      if (hasImage){
        const dir = m < 0 ? new THREE.Vector3(0, -1, 0) : new THREE.Vector3(0,1,0);
        imageArrow.position.set(imgX, 0, 0); imageArrow.setDirection(dir);
        imageArrow.setLength(imgHeight, 14, 8); imageArrow.setColor(new THREE.Color(m < 0 ? 0xffaa44 : 0x44ff44)); imageArrow.visible = true;
      } else {
        imageArrow.visible = false;
      }

      const isFiniteF = Number.isFinite(f) && Math.abs(f) !== Infinity;
      focalHelpers.forEach((h,i) => {
        h.visible = isFiniteF;
        if (!isFiniteF) return;
        const dir = i===0 ? Math.abs(f) : -Math.abs(f);
        h.position.set(dir * scale3D, 0, 0);
        h.material.color.set(lensType === 'convex' ? 0xffd700 : 0xff8800);
      });

      const rayData = {
        objX, objHeight, imgX, imgY, imgHeight, m, f, v, hasImage, realImage: v > 0
      };
      updateRayGroup(raysGroup, rayData);
    }

    // resize
    function resizeCanvases(){
      const leftWidth = Math.floor(window.innerWidth / 2);
      const height = Math.floor(window.innerHeight);
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      diagCanvas.style.width = leftWidth + 'px';
      diagCanvas.style.height = height + 'px';
      diagramRenderer.setPixelRatio(dpr);
      diagramRenderer.setSize(leftWidth, height, false);
      diagramCamera.aspect = leftWidth / height;
      diagramCamera.updateProjectionMatrix();

      viewCanvas.style.width = leftWidth + 'px';
      viewCanvas.style.height = height + 'px';

      updateEverything();
    }
    window.addEventListener('resize', debounce(resizeCanvases, 120));

    // UI
    btnConvex.addEventListener('click', ()=>{ lensType='convex'; setActiveLensBtn(); updateEverything(); });
    btnConcave.addEventListener('click', ()=>{ lensType='concave'; setActiveLensBtn(); updateEverything(); });

    curvatureIn.addEventListener('input', e => { curvature = parseFloat(e.target.value); curvatureValue.textContent = curvature.toFixed(1); updateEverything(); });
    refractiveIn.addEventListener('input', e => { refractiveIndex = parseFloat(e.target.value); refractiveValue.textContent = refractiveIndex.toFixed(2); updateEverything(); });
    objectDistIn.addEventListener('input', e => { objectDistance = parseFloat(e.target.value); objectDistValue.textContent = objectDistance.toFixed(2); updateEverything(); });
    thicknessIn.addEventListener('input', e => { thickness = parseFloat(e.target.value); thicknessValue.textContent = thickness.toFixed(2); updateEverything(); });

    function setActiveLensBtn(){ if (lensType==='convex'){ btnConvex.classList.add('active'); btnConcave.classList.remove('active'); } else { btnConcave.classList.add('active'); btnConvex.classList.remove('active'); } }

    toggleControlsBtn.addEventListener('click', ()=>{ controlsPanel.classList.toggle('hidden'); toggleControlsBtn.setAttribute('aria-expanded', controlsPanel.classList.contains('hidden') ? 'false' : 'true'); });
    toggleInfoBtn.addEventListener('click', ()=>{ infoPanel.classList.toggle('hidden'); toggleInfoBtn.setAttribute('aria-expanded', infoPanel.classList.contains('hidden') ? 'false' : 'true'); });

    btnPreset1.addEventListener('click', ()=>{ objectDistance=12; objectDistIn.value=objectDistance; objectDistValue.textContent=objectDistance.toFixed(2); curvature=1.2; curvatureIn.value=curvature; curvatureValue.textContent=curvature.toFixed(1); refractiveIndex=1.52; refractiveIn.value=refractiveIndex; refractiveValue.textContent=refractiveIndex.toFixed(2); thickness=0.25; thicknessIn.value=thickness; thicknessValue.textContent=thickness.toFixed(2); updateEverything(); });
    btnPreset2.addEventListener('click', ()=>{ objectDistance=2.0; objectDistIn.value=objectDistance; objectDistValue.textContent=objectDistance.toFixed(2); curvature=2.2; curvatureIn.value=curvature; curvatureValue.textContent=curvature.toFixed(1); refractiveIndex=1.6; refractiveIn.value=refractiveIndex; refractiveValue.textContent=refractiveIndex.toFixed(2); thickness=0.45; thicknessIn.value=thickness; thicknessValue.textContent=thickness.toFixed(2); updateEverything(); });
    btnReset.addEventListener('click', resetDefaults);

    function resetDefaults(){
      lensType='convex'; curvature=1.5; refractiveIndex=1.5; objectDistance=5.0; thickness=0.3;
      curvatureIn.value=curvature; refractiveIn.value=refractiveIndex; objectDistIn.value=objectDistance; thicknessIn.value=thickness;
      curvatureValue.textContent=curvature.toFixed(1); refractiveValue.textContent=refractiveIndex.toFixed(2); objectDistValue.textContent=objectDistance.toFixed(2); thicknessValue.textContent=thickness.toFixed(2);
      setActiveLensBtn(); updateEverything();
    }

    // keyboard
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase()==='c'){ lensType='convex'; setActiveLensBtn(); updateEverything(); flashHint(); }
      if (e.key.toLowerCase()==='v'){ lensType='concave'; setActiveLensBtn(); updateEverything(); flashHint(); }
      if (e.key.toLowerCase()==='r'){ resetDefaults(); flashHint(); }
    });

    let hintTimer=null;
    function flashHint(){ const hints = document.getElementById('footerHints'); hints.style.opacity='1'; clearTimeout(hintTimer); hintTimer=setTimeout(()=> hints.style.opacity='0.35',900); }

    // info updates
    function updateInfoPanel(){
      const { f, v, m } = calculateImage();
      infoType.textContent = lensType === 'convex' ? 'Cembung (Konvergen)' : 'Cekung (Divergen)';
      infoFocus.textContent = (f === Infinity || !isFinite(f)) ? '∞' : f.toFixed(2);
      infoImageDist.textContent = (v === Infinity || !isFinite(v)) ? '∞' : v.toFixed(2);
      infoMag.textContent = (m === Infinity || !isFinite(m)) ? '∞' : m.toFixed(2);
      let nature = '-';
      if (!isFinite(v) || !isFinite(m)) nature = 'Tidak terbentuk';
      else if (lensType === 'convex') {
        if (v > 0 && m < -1) nature = 'Nyata, terbalik, diperbesar';
        else if (v > 0 && m < 0 && m >= -1) nature = 'Nyata, terbalik, diperkecil';
        else if (v < 0 && m > 0) nature = 'Maya, tegak, diperbesar';
      } else {
        nature = 'Maya, tegak, diperkecil';
      }
      infoNature.textContent = nature;
    }

    function updateEverything(){ updateDiagramScene(); drawView(); updateInfoPanel(); }

    // init
    resizeCanvases();
    resetDefaults();

    // utils
    function debounce(fn, wait=100){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }
  </script>
</body>
</html>
